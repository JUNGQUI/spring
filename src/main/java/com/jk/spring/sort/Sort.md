### 정렬

각 정렬의 로직과 시간복잡도 등을 정리하기 위한 패키지

### O(n^2)

- [Bubble](./Bubble.java)

O(n^2) 의 시간 복잡도를 가진 정렬로, 베스트 케이스의 경우 단 한번만 실행하면 정렬이 되나, 그 외의 경우
끝까지 정렬하는 것을 원소의 개수만큼 진행하게 되기 때문에 사용하지 않는다.

요새는 정렬 알고리즘의 기초를 알려주기 위해 소개가 되는 정렬로 실제로 쓰이지 않는다.

로직을 살펴보면 원소의 현재 idx 값, 그 다음 idx 값 두 가지를 비교하고 정렬한다.
그 다음엔 다시 다음 idx 의 현재 값과 그 다음 idx 두 가지를 또 비교하고 이를 원소의 끝까지 진행한다.

이렇게 진행 한 후 다시 첫 인덱스로 가서 다시 같은 루틴을 반복하고 이를 전체 원소만큼 수행한다.

- [Select](./Select.java)

마찬가지로 O(n^2) 의 시간복잡도를 가지고 있으며 버블정렬과 다른 점은 항상 균일한 시간 복잡도를 가지고 있다는 것이다.
기본적인 로직은 가장 작은 (혹은 가장 큰) 값 하나를 전체에서 찾아서 맨 앞(혹은 맨 뒤) 배치하고 그 다음 원소에 대해 다시 동일한
정렬 로직을 수행하게 된다.

따라서 전체 로직의 n 팩토리얼만큼 수행되기 때문에 O(n^2) 이 수행되고 이 값은 전체 정렬이 되어있던, 안되어 있던 균일한 시간 복잡도를 가지는게
특징이다.

### O(nlogn)

- [Merge](./Merge.java)

O(nlogn) 수치를 가진 알고리즘으로 0 또는 1개의 원소를 가질때까지 나눠두고 그 나눠진 배열들을 다시 하나씩 비교해가며 정렬하는 방식이다.
최대한의 한도로 나눈 후 정렬하여 사용하기 때문에 비교하는 양쪽 모두 각 배열군에서는 정렬이 되어있고 그렇기 때문에 비교 시 시간을 절약 할 수 있다.

다른 O(nlogn) 정렬과 비교 시 장점은 데이터의 상태에 따라 알고리즘의 성능이 달라지진 않는다는 점이다. 다만 단점으로는 데이터 양만큼의 메모리가 소모되고,
다른 정렬들과 비교해서 성능이 특출나진 않다는 점이다.

흔히 divide and conquer 라 불리는 분할-정복 알고리즘이 이와 동일하다.

