### DSL (Domain-Specific Language)

DSL 이란 해석하면 도메인 정의어 라고 말 할 수 있다. 대표적인 DSL 엔 maven, gradle 과 같이 `build` 라는 도메인에 묶여 정의된
언어라고 볼 수 있고, HTML 의 경우 웹페이지의 구조를 정의하도록 특화된, `Web page 라는 도메인`의 정의어 라고 볼 수 있다.

다음과 같은 로직이 있다고 가정해보자.

```
...
while (block != null) {
    read(block, buffer)
    for (every record in buffer) {
        if (record.calorie < 400) {
            System.out.println(record.name);
        }
    }
    block = buffer.next();
}
...
```

간단한 슈도코드(pseudo code)로 구현을 한 로직으로, block 이 null 일때 까지 반복문을 도는데 버퍼로부터 값을 읽어서 칼로리가 400 이하일 경우
화면에 출력한다.

이를 해결하는 방법은 두 가지인데, 첫번째는 근본적인 해결책이다. DB 에서 데이터를 가져올 때 부터 400 이하의 요소들만을 가져오는 것이다.
이러한 케이스를 기술적으로 외부적 DSL 이라고 하는데, 말 그대로 이슈가 발생한 계층에서의 해결이 아닌, 그 이전 혹은 이후의 계층에서 해결하는 것이다.

반대로 내부적 DSL 은 아래와 같다.

```
...
menu.stream()
    .filter(d -> d.getCalories() < 400)
    .map(Dish::getName)
    .forEach(System.out::println)
...
```

이처럼 위와 같은 반복문 안에 새로운 반복문 형식으로 구현을 해서 가독성을 줄이는 것 보단 전체 메뉴를 불러와서 stream 을 통해 순회하며 원하는 로직을 수행하게 하는것이
훨씬 더 경제적일 뿐더러 가독성 측면에서도 훌륭하다.

정리하자면 DSL 을 관통하는 큰 줄기는 두 가지가 있는데

1. 의사소통 : 비개발자가 코드를 읽고 이해가 가능해야 한다.

사실 의미는 실제로 비 개발자가 이해할 수 있을 정도의 느낌이라기 보단 해당 도메인에 맞는 비즈니스로직 해결에만 집중되어 있는 간편한 구조를 뜻한다.
모듈을 점점 작게 꾸미고 그 작은 범위 내에서 법칙을 정하여 사용하면 훌륭한 DSL 이라고 볼 수 있다. 이렇게 할 경우 로직이 단순화되어 손쉽게 로직을 이해할 수 있을
뿐더러 어떤 변화가 필요하게 되더라도 이미 해당 비즈니스 로직에 대해 정의가 되어있는 상태에서 간단하게 짜여진 구조라 변화에도 유연하게 대처가 가능하다.

2. 가독성 : 로직을 모르는 개발자가 로직을 배울 수 있어야 한다.

가독성은 유지보수의 기본이다. 코딩 컨벤션이라는 단어가 있을만큼 가독성이 개발에서 차지하는 비중이 크다.

DSL 은 이러한 특성에 맞게 만들 수 있어야 한다. 자칫 잘못 적용하여 가독성이 좋지 않은 DSL 을 만들 경우 오히려 없느니만 못한, 역효과를 불러 일으킬 수 있다.