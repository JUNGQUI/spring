### DSL (Domain-Specific Language)

DSL 이란 해석하면 도메인 정의어 라고 말 할 수 있다. 대표적인 DSL 엔 maven, gradle 과 같이 `build` 라는 도메인에 묶여 정의된
언어라고 볼 수 있고, HTML 의 경우 웹페이지의 구조를 정의하도록 특화된, `Web page 라는 도메인`의 정의어 라고 볼 수 있다.

다음과 같은 로직이 있다고 가정해보자.

```
...
while (block != null) {
    read(block, buffer)
    for (every record in buffer) {
        if (record.calorie < 400) {
            System.out.println(record.name);
        }
    }
    block = buffer.next();
}
...
```

간단한 슈도코드(pseudo code)로 구현을 한 로직으로, block 이 null 일때 까지 반복문을 도는데 버퍼로부터 값을 읽어서 칼로리가 400 이하일 경우
화면에 출력한다.

이를 해결하는 방법은 두 가지인데, 첫번째는 근본적인 해결책이다. DB 에서 데이터를 가져올 때 부터 400 이하의 요소들만을 가져오는 것이다.
이러한 케이스를 기술적으로 외부적 DSL 이라고 하는데, 말 그대로 이슈가 발생한 계층에서의 해결이 아닌, 그 이전 혹은 이후의 계층에서 해결하는 것이다.

반대로 내부적 DSL 은 아래와 같다.

```
...
menu.stream()
    .filter(d -> d.getCalories() < 400)
    .map(Dish::getName)
    .forEach(System.out::println)
...
```

이처럼 위와 같은 반복문 안에 새로운 반복문 형식으로 구현을 해서 가독성을 줄이는 것 보단 전체 메뉴를 불러와서 stream 을 통해 순회하며 원하는 로직을 수행하게 하는것이
훨씬 더 경제적일 뿐더러 가독성 측면에서도 훌륭하다.

정리하자면 DSL 을 관통하는 큰 줄기는 두 가지가 있는데

1. 의사소통 : 비개발자가 코드를 읽고 이해가 가능해야 한다.

사실 의미는 실제로 비 개발자가 이해할 수 있을 정도의 느낌이라기 보단 해당 도메인에 맞는 비즈니스로직 해결에만 집중되어 있는 간편한 구조를 뜻한다.
모듈을 점점 작게 꾸미고 그 작은 범위 내에서 법칙을 정하여 사용하면 훌륭한 DSL 이라고 볼 수 있다. 이렇게 할 경우 로직이 단순화되어 손쉽게 로직을 이해할 수 있을
뿐더러 어떤 변화가 필요하게 되더라도 이미 해당 비즈니스 로직에 대해 정의가 되어있는 상태에서 간단하게 짜여진 구조라 변화에도 유연하게 대처가 가능하다.

2. 가독성 : 로직을 모르는 개발자가 로직을 배울 수 있어야 한다.

가독성은 유지보수의 기본이다. 코딩 컨벤션이라는 단어가 있을만큼 가독성이 개발에서 차지하는 비중이 크다.

DSL 은 이러한 특성에 맞게 만들 수 있어야 한다. 자칫 잘못 적용하여 가독성이 좋지 않은 DSL 을 만들 경우 오히려 없느니만 못한, 역효과를 불러 일으킬 수 있다.

---

- 장/단점

장점

- 간결함 : 말 그대로 간결성이다. 비즈니스 로직에 맞게 내부에서만 사용하는 약어등을 이용해 코드를 더 깔끔하게 가져갈 수 있다.
- 가독성 : 위와 동일하다. 이미 약속을 통해 비즈니스 로직에 맞게 단어를 정의하였으므로 가독성 측면에서도 좋아진다.
- 유지보수 : 가독성과 연결되는 부분이다. 가독성 증대는 곧 새로운 개발자의 유입에도 유연하게 대처가 가능하다.
- 추상화 : 내부 비즈니스 로직에 특화되어 만들어지는 언어이기에 내부 비즈니스 로직 한정으로는 훌륭한 추상화를 제공한다.
- 집중 : 위와 동일하다. 내부 비즈니스 로직에 한해 정의를 하였기에 해당 단어가 이중성을 띄지 않는다.
- 관심사 분리 : 위와 동일하다. 외부에서 사용하는 단어랑은 다르게 해당 단어들 및 정의는 비즈니스 로직 내에서는 유일하기에 관심사가 분리되어 구현하기 편리해진다.

단점

- 진입장벽 : 위와 같은 장점들을 가져가기 위해선 초기 설계에서 많은 생각과 사고가 필요하다.
- 개발비용 : 위와 동일하다. 진입장벽이 높은터라 한번 DSL 을 제대로 정의하기에 코스트가 높다.
- 추가 계층 : 비즈니스 로직에 특화된 언어쳬계로 만들다 보니 내부에서 필요악적인 추가 계층이 추가될 가능성이 높다. 컨트롤러 단에서 추가 검증을 위한 서비스 단을 별도로 구성하는
  등의 이슈에 해당한다.
- 새로운 언어 : 새로 만들어지는 완전 새로운 언어이기에 배우기가 까다롭다. 즉, 새로운 인력 투입이 추후에 효력을 발휘한다는 의미다.
- 호스팅 언어 종속 : 아무리 새 언어여도 결국에는 개발하는 주체의 개발 언어의 로직에서 벗어날 수 없다. 구조적 한계로 구현을 하지 못하는 부분에 대해서는 DSL 을 아무리
잘 만든다 하더라도 결국 그 이상으로 개선이 될 순 없다.
  
---

- 내부 DSL

앞서 이야기했듯 종속된 언어로 DSL 을 표현할 때 내부 DSL 이라고 칭한다. 예컨데, 자바로 개발한 프로젝트에서 자바를 베이스로 DSL 을 정의 한다면
내부 DSL 이라곱 ㅗㄹ 수 있다.

```
...
List<String> numbers = Arrays.asList("one", "two", "three");
// 이 부분을
numbers.forEach(new Consumer<String>() {
  @Override
  public void accept(String s) {
    System.out.println(s);
  }
});
// 이렇게 변경이 가능하다.
numbers.forEach(s -> System.out::println);
...
```

전체 로직 중 중요한 골자는 `numbers 라는 배열은 String 으로 이루어져 있고 Consumer 를 통해서 전체 배열을 순회하면서 화면에 1회씩 출력한다` 라는 것이 중요하고
이러한 로직만을 포함하게 새로운 DSL 을 람다를 통해서 정의하였다. forEach 로 순회하되 람다와 메서드 참조를 통해 반복문, Consumer, accept 를 제외시켰다.

이런 내부 DSL 을 이용하면 결과적으로 언어에 있는 기능을 사용하기에 초기 학습단계만 건너면 추후 진행하는데에 큰 코스트가 들지 않고 IDE 등 디버거의 도움도 받을 수 있으며
무엇보다 개발자가 능숙하게 사용하는 패턴들이기에 초기 학습단계도 아주 부드럽게 넘어갈 수 있다.

---

- 외부 DSL

내부 DSL 과는 반대로 외부 요소를 이용해 DSL 을 정의하는 것을 의미한다. 쉽게 말해 앞서 이야기한 예제 중 반복에 대해 데이터 자체를
where 절을 이용해서 DB 로부터 가져와서 계산을 할 필요가 없게 결과를 뽑아내는 부분이 있었는데, 이와 같은 방법이 외부 DSL 을 이용하는 것이라고 볼 수 있다.

---

