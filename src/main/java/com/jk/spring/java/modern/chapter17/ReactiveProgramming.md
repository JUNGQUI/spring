### 리액티브 프로그래밍

리액티브 프로그래밍은 데이터가 엄청나게 많아지고, 클라우드, 모바일 등 다양한 환경의 구성, 사용자가 항시 소지가 가능한 사용 패턴의
변화들로 인해 두드러지게 발달하게 되었다.

많은 사용자가 자신의 애플리케이션이 느슨하게 구성이 되어있다고 하지만 실제로 하나의 애플리케이션에 여러 모듈이 집약되어 있는 구조를
띄는 경우가 많고, 이럴 경우 리액티브라고 보기 어렵다.

- 리액티브 매니패스토

리액티브 애플리케이션과 시스템 개발의 핵심 원칙을 의미한다.

1. 반응성 - 리액티브라는 말 처럼 응답까지의 시간이 굉장히 빠르게 제공이 되어야 한다.
2. 회복성 - 장애가 발생하더라도 극히 일부분에만 영향을 끼치거나 영향이 없어야 하고 해당 컴포넌트의 역할을 다른 컴포넌트가 수행하는 회복능력이 중요하다.
3. 탄력성 - 반응성과 연계되어 과도한 요청이 들어오더라도 자원에 대해 빠르게 수급하여 반응성을 헤치지 않아야 한다.
4. 메시지 주도 - 비동기 메시지를 통해 컴포넌트끼리의 통신이 이루어져야 한다. 쉽게 말해 비동기적으로 여러 모듈이 구동되며 하나의 응답이
완료될 경우 그때까지 기다리는 것이 아닌 해당 모듈에서 완료가 되었을 때 메시지(이벤트) 를 보내 호출했던 모듈을 불러와 작업을 진행하는 방식이 되어야 한다.

가장 길게 썼기에 이미 눈치챘을지 모르지만 매니패스토에서 반응성, 회복성, 탄력성은 메시지 주도라는 원툴에 영향을 크게 받는다. 즉, 가장 주요한
속성은 메시지 주도 방식이라고 볼 수 있다.

- 시스템 수준의 리액티브

리액티브 프로그래밍을 시스템 수준에서 보게 된다면 앞서 이야기 했듯 가장 주요한 부분이 메시지 주도이다. 시스템에서 장애가 발생 했을 때
장애가 전체 시스템으로 퍼져나가는 것을 막기 위해서는 격리가 되어야 한다.

이렇게 시스템에 장애가 발생했을 경우 서서히 성능이 저하되는 것이 아니라 문제 자체를 격리함으로써 시스템을 건강한 상태로 되돌리고 이를 가능하게 하는것은
에러 자체를 메시지로 컨버팅해서 컴포넌트로 에러가 발생했음을 알리게 하고 에러 자체를 전달하진 않게끔 만드는 것이 핵심이다.
이러한 '마법' 이 적용될 수 있는 핵심은 위치 투명성이다. 위치 투명성이란 모든 컴포넌트가 메시지로 통신 할 때 위치를 따지지 않고 통신이
가능함을 의미한다.

### 리액티브 스트림과 플로 API

리액티브 프로그래밍에서 사용하는 스트림을 리액티브 스트림이라 칭하는데 잠재적으로 무한의 비동기 데이터를 순서대로, 블록하지 않는 역압력을 전제해
처리하는 표준 기술이다.

스트림 처리의 비동기적 특성상 역압력은 필수적인데 리액티브 스트림 프로젝트에서 큰 몇가지 인터페이스가 존재하는데, 자바9의 Flow, Akka 스트림,
리액터, RxJava, Vert.x 등이 있다.

> 역압력? (back-pressure)
> 
> pub-sub model 에서 사용하는 용어로, 하나의 작업이 발생하고 끝날때까지 기다리는 일반적인 모델과 달리 작업을 처리하는 모듈을
> 구독(subscribe)하고 해당 모듈이 작업을 완료할 경우 이벤트를 발생(publish) 시켜 구독중인 모듈에 작업 종료를 알려 비동기적으로 처리하는
> 전략 패턴이다.
> 
> 여기에서 둘의 속도가 (작업 발생 vs 작업 완료) 별 차이 없다면 꾸준하게 작업이 비동기적으로 진행하며 큰 이점을 가질 수 있으나 완료되는
> 시간보다 발생하는 시간이 더 빠를 경우 과부하가 일어 날 수 있다.
> 
> 이러한 부분을 작업을 처리하는 쪽에서 작업을 요청하는 모듈에 시그널을 보냄으로써 작업 요청의 시간을 조정하는 것을 역압력이라 한다.

Flow 클래스에서는 아래와 같이 4가지 인터페이스를 제공한다.

- Publisher
- Subscriber
- Subscription
- Processor

```java
import java.util.concurrent.Flow.Subscription;

@FunctionalInterface
public interface Publisher<T> {

  void subscribe(Subscriber<? super T> s);
}

public interface Subscriber<T> {
  void onSubscribe(Subscription s);
  void onNext(T t);
  void onError(Throwable t);
  void onComplete();
}

public interface Subscription {
  void request(long n);
  void cancel();
}

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {}
```

pub-sub 에서 work flow 는 아래와 같이 발행되어야 한다.

`onSubscribe - onNext* - (onError | onComplete)?`

onSubscribe 로 최초 구독 후 onNext 는 로직에 따라 여러번 수행이 될 수 있고, 이후엔 선택에 따라 onError, onComplete (혹은 무한히 가동)
처리가 되어야 한다.

Subscription 은 request 를 통해 발행자가 구독자에게 얼만큼의 요청을 보낼지 정하고, cancel 의 경우 더이상 구독하지 않겠다는 이벤트를 발생시킨다.

이 리액티브 스트림을 이용한 애플리케이션을 만들건데 조건은 다음과 같다.

- TempInfo : 원격 온도계, 0~99 온도를 임의로 만들어 연속보고
- TempSubscriber : 레포트를 관찰하면서 온도 스트림 출력